{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/core/defi/butter/ButterBatchProcessing.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../../utils/ContractRegistryAccess.sol\";\nimport \"../../utils/ACLAuth.sol\";\nimport \"../../utils/KeeperIncentivized.sol\";\nimport \"../../../externals/interfaces/YearnVault.sol\";\nimport \"../../../externals/interfaces/BasicIssuanceModule.sol\";\nimport \"../../../externals/interfaces/ISetToken.sol\";\nimport \"../../../externals/interfaces/CurveContracts.sol\";\nimport \"../../interfaces/IStaking.sol\";\nimport \"../../interfaces/IKeeperIncentive.sol\";\n\n/*\n * @notice This Contract allows smaller depositors to mint and redeem Butter (formerly known as HYSI) without needing to through all the steps necessary on their own,\n * which not only takes long but mainly costs enormous amounts of gas.\n * The Butter is created from several different yTokens which in turn need each a deposit of a crvLPToken.\n * This means multiple approvals and deposits are necessary to mint one Butter.\n * We batch this process and allow users to pool their funds. Then we pay a keeper to mint or redeem Butter regularly.\n */\ncontract ButterBatchProcessing is Pausable, ReentrancyGuard, ACLAuth, KeeperIncentivized, ContractRegistryAccess {\n  using SafeERC20 for YearnVault;\n  using SafeERC20 for ISetToken;\n  using SafeERC20 for IERC20;\n\n  /**\n   * @notice Defines if the Batch will mint or redeem Butter\n   */\n  enum BatchType {\n    Mint,\n    Redeem\n  }\n\n  /**\n   * @notice Defines if the Batch will mint or redeem Butter\n   * @param curveMetaPool A CurveMetaPool for trading an exotic stablecoin against 3CRV\n   * @param crvLPToken The LP-Token of the CurveMetapool\n   */\n  struct CurvePoolTokenPair {\n    CurveMetapool curveMetaPool;\n    IERC20 crvLPToken;\n  }\n\n  struct ProcessingThreshold {\n    uint256 batchCooldown;\n    uint256 mintThreshold;\n    uint256 redeemThreshold;\n  }\n\n  struct RedemptionFee {\n    uint256 accumulated;\n    uint256 rate;\n    address recipient;\n  }\n\n  struct Slippage {\n    uint256 mintBps; // in bps\n    uint256 redeemBps; // in bps\n  }\n\n  /**\n   * @notice The Batch structure is used both for Batches of Minting and Redeeming\n   * @param batchType Determines if this Batch is for Minting or Redeeming Butter\n   * @param batchId bytes32 id of the batch\n   * @param claimable Shows if a batch has been processed and is ready to be claimed, the suppliedToken cant be withdrawn if a batch is claimable\n   * @param unclaimedShares The total amount of unclaimed shares in this batch\n   * @param suppliedTokenBalance The total amount of deposited token (either 3CRV or Butter)\n   * @param claimableTokenBalance The total amount of claimable token (either 3CRV or Butter)\n   * @param tokenAddress The address of the the token to be claimed\n   * @param shareBalance The individual share balance per user that has deposited token\n   */\n  struct Batch {\n    BatchType batchType;\n    bytes32 batchId;\n    bool claimable;\n    uint256 unclaimedShares;\n    uint256 suppliedTokenBalance;\n    uint256 claimableTokenBalance;\n    address suppliedTokenAddress;\n    address claimableTokenAddress;\n  }\n\n  /* ========== STATE VARIABLES ========== */\n\n  bytes32 public immutable contractName = \"ButterBatchProcessing\";\n\n  IStaking public staking;\n  ISetToken public setToken;\n  IERC20 public threeCrv;\n  CurveMetapool public threePool;\n  BasicIssuanceModule public setBasicIssuanceModule;\n  mapping(address => CurvePoolTokenPair) public curvePoolTokenPairs;\n\n  /**\n   * @notice This maps batch ids to addresses with share balances\n   */\n  mapping(bytes32 => mapping(address => uint256)) public accountBalances;\n  mapping(address => bytes32[]) public accountBatches;\n  mapping(bytes32 => Batch) public batches;\n  bytes32[] public batchIds;\n\n  uint256 public lastMintedAt;\n  uint256 public lastRedeemedAt;\n  bytes32 public currentMintBatchId;\n  bytes32 public currentRedeemBatchId;\n\n  Slippage public slippage;\n  ProcessingThreshold public processingThreshold;\n\n  RedemptionFee public redemptionFee;\n\n  mapping(address => bool) public sweethearts;\n\n  /* ========== EVENTS ========== */\n\n  event Deposit(address indexed from, uint256 deposit);\n  event Withdrawal(address indexed to, uint256 amount);\n  event SlippageUpdated(Slippage prev, Slippage current);\n  event BatchMinted(bytes32 batchId, uint256 suppliedTokenAmount, uint256 butterAmount);\n  event BatchRedeemed(bytes32 batchId, uint256 suppliedTokenAmount, uint256 threeCrvAmount);\n  event Claimed(address indexed account, BatchType batchType, uint256 shares, uint256 claimedToken);\n  event WithdrawnFromBatch(bytes32 batchId, uint256 amount, address indexed to);\n  event MovedUnclaimedDepositsIntoCurrentBatch(uint256 amount, BatchType batchType, address indexed account);\n  event CurveTokenPairsUpdated(address[] yTokenAddresses, CurvePoolTokenPair[] curveTokenPairs);\n  event ProcessingThresholdUpdated(ProcessingThreshold previousThreshold, ProcessingThreshold newProcessingThreshold);\n  event RedemptionFeeUpdated(uint256 newRedemptionFee, address newFeeRecipient);\n  event SweetheartUpdated(address sweetheart, bool isSweeheart);\n  event StakingUpdated(address beforeAddress, address afterAddress);\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    IContractRegistry _contractRegistry,\n    IStaking _staking,\n    ISetToken _setToken,\n    IERC20 _threeCrv,\n    CurveMetapool _threePool,\n    BasicIssuanceModule _basicIssuanceModule,\n    address[] memory _yTokenAddresses,\n    CurvePoolTokenPair[] memory _curvePoolTokenPairs,\n    ProcessingThreshold memory _processingThreshold\n  ) ContractRegistryAccess(_contractRegistry) {\n    staking = _staking;\n    setToken = _setToken;\n    threeCrv = _threeCrv;\n    threePool = _threePool;\n    setBasicIssuanceModule = _basicIssuanceModule;\n\n    _setCurvePoolTokenPairs(_yTokenAddresses, _curvePoolTokenPairs);\n\n    processingThreshold = _processingThreshold;\n\n    lastMintedAt = block.timestamp;\n    lastRedeemedAt = block.timestamp;\n\n    _generateNextBatch(bytes32(\"mint\"), BatchType.Mint);\n    _generateNextBatch(bytes32(\"redeem\"), BatchType.Redeem);\n\n    slippage.mintBps = 7;\n    slippage.redeemBps = 7;\n  }\n\n  /* ========== VIEWS ========== */\n  /**\n   * @notice Get ids for all batches that a user has interacted with\n   * @param _account The address for whom we want to retrieve batches\n   */\n  function getAccountBatches(address _account) external view returns (bytes32[] memory) {\n    return accountBatches[_account];\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @notice Deposits funds in the current mint batch\n   * @param _amount Amount of 3cr3CRV to use for minting\n   * @param _depositFor User that gets the shares attributed to (for use in zapper contract)\n   */\n  function depositForMint(uint256 _amount, address _depositFor)\n    external\n    nonReentrant\n    whenNotPaused\n    onlyApprovedContractOrEOA\n  {\n    require(\n      _hasRole(keccak256(\"ButterZapper\"), msg.sender) || msg.sender == _depositFor,\n      \"you cant transfer other funds\"\n    );\n    require(threeCrv.balanceOf(msg.sender) >= _amount, \"insufficent balance\");\n    threeCrv.transferFrom(msg.sender, address(this), _amount);\n    _deposit(_amount, currentMintBatchId, _depositFor);\n  }\n\n  /**\n   * @notice deposits funds in the current redeem batch\n   * @param _amount amount of Butter to be redeemed\n   */\n  function depositForRedeem(uint256 _amount) external nonReentrant whenNotPaused onlyApprovedContractOrEOA {\n    require(setToken.balanceOf(msg.sender) >= _amount, \"insufficient balance\");\n    setToken.transferFrom(msg.sender, address(this), _amount);\n    _deposit(_amount, currentRedeemBatchId, msg.sender);\n  }\n\n  /**\n   * @notice This function allows a user to withdraw their funds from a batch before that batch has been processed\n   * @param _batchId From which batch should funds be withdrawn from\n   * @param _amountToWithdraw Amount of Butter or 3CRV to be withdrawn from the queue (depending on mintBatch / redeemBatch)\n   * @param _withdrawFor User that gets the shares attributed to (for use in zapper contract)\n   */\n  function withdrawFromBatch(\n    bytes32 _batchId,\n    uint256 _amountToWithdraw,\n    address _withdrawFor\n  ) external {\n    address recipient = _getRecipient(_withdrawFor);\n\n    Batch storage batch = batches[_batchId];\n    uint256 accountBalance = accountBalances[_batchId][_withdrawFor];\n    require(batch.claimable == false, \"already processed\");\n    require(accountBalance >= _amountToWithdraw, \"account has insufficient funds\");\n\n    //At this point the account balance is equal to the supplied token and can be used interchangeably\n    accountBalances[_batchId][_withdrawFor] = accountBalance - _amountToWithdraw;\n    batch.suppliedTokenBalance = batch.suppliedTokenBalance - _amountToWithdraw;\n    batch.unclaimedShares = batch.unclaimedShares - _amountToWithdraw;\n\n    if (batch.batchType == BatchType.Mint) {\n      threeCrv.safeTransfer(recipient, _amountToWithdraw);\n    } else {\n      setToken.safeTransfer(recipient, _amountToWithdraw);\n    }\n    emit WithdrawnFromBatch(_batchId, _amountToWithdraw, _withdrawFor);\n  }\n\n  /**\n   * @notice Claims funds after the batch has been processed (get Butter from a mint batch and 3CRV from a redeem batch)\n   * @param _batchId Id of batch to claim from\n   * @param _claimFor User that gets the shares attributed to (for use in zapper contract)\n   */\n  function claim(bytes32 _batchId, address _claimFor) external returns (uint256) {\n    (address recipient, BatchType batchType, uint256 accountBalance, uint256 tokenAmountToClaim) = _prepareClaim(\n      _batchId,\n      _claimFor\n    );\n    //Transfer token\n    if (batchType == BatchType.Mint) {\n      setToken.safeTransfer(recipient, tokenAmountToClaim);\n    } else {\n      //We only want to apply a fee on redemption of Butter\n      //Sweethearts are partner addresses that we want to exclude from this fee\n      if (!sweethearts[_claimFor]) {\n        //Fee is deducted from threeCrv -- This allows it to work with the Zapper\n        //Fes are denominated in BasisPoints\n        uint256 fee = (tokenAmountToClaim * redemptionFee.rate) / 10_000;\n        redemptionFee.accumulated += fee;\n        tokenAmountToClaim = tokenAmountToClaim - fee;\n      }\n      threeCrv.safeTransfer(recipient, tokenAmountToClaim);\n    }\n    emit Claimed(recipient, batchType, accountBalance, tokenAmountToClaim);\n\n    return tokenAmountToClaim;\n  }\n\n  /**\n   * @notice Claims BTR after batch has been processed and stakes it in Staking.sol\n   * @param _batchId Id of batch to claim from\n   * @param _claimFor User that gets the shares attributed to (for use in zapper contract)\n   */\n  function claimAndStake(bytes32 _batchId, address _claimFor) external {\n    (address recipient, BatchType batchType, uint256 accountBalance, uint256 tokenAmountToClaim) = _prepareClaim(\n      _batchId,\n      _claimFor\n    );\n    emit Claimed(recipient, batchType, accountBalance, tokenAmountToClaim);\n\n    //Transfer token\n    require(batchType == BatchType.Mint, \"Can only stake BTR\");\n    staking.stakeFor(tokenAmountToClaim, recipient);\n  }\n\n  /**\n   * @notice Moves unclaimed token (3crv or butter) from their respective Batches into a new redeemBatch / mintBatch without needing to claim them first. This will typically be used when butter has already been minted and a user has never claimed / transfered the token to their address and they would like to convert it to stablecoin.\n   * @param _batchIds the ids of each batch where butter should be moved from\n   * @param _shares how many shares should redeemed in each of the batches\n   * @param _batchType the batchType where funds should be taken from (Mint -> Take Hysi and redeem then, Redeem -> Take 3Crv and Mint Butter)\n   * @dev the indices of batchIds must match the amountsInHysi to work properly (This will be done by the frontend)\n   */\n  function moveUnclaimedDepositsIntoCurrentBatch(\n    bytes32[] calldata _batchIds,\n    uint256[] calldata _shares,\n    BatchType _batchType\n  ) external whenNotPaused {\n    require(_batchIds.length == _shares.length, \"array lengths must match\");\n\n    uint256 totalAmount;\n\n    for (uint256 i; i < _batchIds.length; i++) {\n      Batch storage batch = batches[_batchIds[i]];\n      uint256 accountBalance = accountBalances[batch.batchId][msg.sender];\n      //Check that the user has enough funds and that the batch was already minted\n      //Only the current redeemBatch is claimable == false so this check allows us to not adjust batch.suppliedTokenBalance\n      //Additionally it makes no sense to move funds from the current redeemBatch to the current redeemBatch\n      require(batch.claimable == true, \"has not yet been processed\");\n      require(batch.batchType == _batchType, \"incorrect batchType\");\n      require(accountBalance >= _shares[i], \"account has insufficient funds\");\n\n      uint256 tokenAmountToClaim = (batch.claimableTokenBalance * _shares[i]) / batch.unclaimedShares;\n      batch.claimableTokenBalance = batch.claimableTokenBalance - tokenAmountToClaim;\n      batch.unclaimedShares = batch.unclaimedShares - _shares[i];\n      accountBalances[batch.batchId][msg.sender] = accountBalance - _shares[i];\n\n      totalAmount = totalAmount + tokenAmountToClaim;\n    }\n    require(totalAmount > 0, \"totalAmount must be larger 0\");\n\n    if (BatchType.Mint == _batchType) {\n      _deposit(totalAmount, currentRedeemBatchId, msg.sender);\n    }\n\n    if (BatchType.Redeem == _batchType) {\n      _deposit(totalAmount, currentMintBatchId, msg.sender);\n    }\n\n    emit MovedUnclaimedDepositsIntoCurrentBatch(totalAmount, _batchType, msg.sender);\n  }\n\n  /**\n   * @notice Mint Butter token with deposited 3CRV. This function goes through all the steps necessary to mint an optimal amount of Butter\n   * @dev This function deposits 3CRV in the underlying Metapool and deposits these LP token to get yToken which in turn are used to mint Butter\n   * @dev This process leaves some leftovers which are partially used in the next mint batches.\n   * @dev In order to get 3CRV we can implement a zap to move stables into the curve tri-pool\n   * @dev handleKeeperIncentive checks if the msg.sender is a permissioned keeper and pays them a reward for calling this function (see KeeperIncentive.sol)\n   */\n  function batchMint() external whenNotPaused keeperIncentive(contractName, 0) {\n    Batch storage batch = batches[currentMintBatchId];\n    //Check if there was enough time between the last batch minting and this attempt...\n    //...or if enough 3CRV was deposited to make the minting worthwhile\n    //This is to prevent excessive gas consumption and costs as we will pay keeper to call this function\n    require(\n      ((block.timestamp - lastMintedAt) >= processingThreshold.batchCooldown ||\n        (batch.suppliedTokenBalance >= processingThreshold.mintThreshold)) && batch.suppliedTokenBalance > 0,\n      \"can not execute batch mint yet\"\n    );\n\n    //Check if the Batch got already processed -- should technically not be possible\n    require(batch.claimable == false, \"already minted\");\n\n    //Check if this contract has enough 3CRV -- should technically not be necessary\n    require(\n      threeCrv.balanceOf(address(this)) >= batch.suppliedTokenBalance,\n      \"account has insufficient balance of token to mint\"\n    );\n\n    //Get the quantities of yToken needed to mint 1 BTR (This should be an equal amount per Token)\n    (address[] memory tokenAddresses, uint256[] memory quantities) = setBasicIssuanceModule\n      .getRequiredComponentUnitsForIssue(setToken, 1e18);\n\n    //The value of 1 BTR in virtual Price (`quantities` * `virtualPrice`)\n    uint256 setValue = valueOfComponents(tokenAddresses, quantities);\n\n    uint256 threeCrvValue = threePool.get_virtual_price();\n\n    //Remaining amount of 3CRV in this batch which hasnt been allocated yet\n    uint256 remainingBatchBalanceValue = (batch.suppliedTokenBalance * threeCrvValue) / 1e18;\n\n    //Temporary allocation of 3CRV to be deployed in curveMetapools\n    uint256[] memory poolAllocations = new uint256[](quantities.length);\n\n    //Ratio of 3CRV needed to mint 1 BTR\n    uint256[] memory ratios = new uint256[](quantities.length);\n\n    for (uint256 i; i < tokenAddresses.length; i++) {\n      // prettier-ignore\n      (uint256 allocation, uint256 ratio) = _getPoolAllocationAndRatio(tokenAddresses[i], quantities[i], batch, setValue, threeCrvValue);\n      poolAllocations[i] = allocation;\n      ratios[i] = ratio;\n      remainingBatchBalanceValue -= allocation;\n    }\n\n    for (uint256 i; i < tokenAddresses.length; i++) {\n      uint256 poolAllocation;\n\n      //RemainingLeftovers should only be 0 if there were no yToken leftover from previous batches\n      //since the first iteration of poolAllocation uses all 3CRV. Therefore we can only have `remainingBatchBalanceValue` from subtracted leftovers\n      if (remainingBatchBalanceValue > 0) {\n        poolAllocation = _getPoolAllocation(remainingBatchBalanceValue, ratios[i]);\n      }\n\n      //Pool 3CRV to get crvLPToken\n      _sendToCurve(\n        ((poolAllocation + poolAllocations[i]) * 1e18) / threeCrvValue,\n        curvePoolTokenPairs[tokenAddresses[i]].curveMetaPool\n      );\n\n      //Deposit crvLPToken to get yToken\n      _sendToYearn(\n        curvePoolTokenPairs[tokenAddresses[i]].crvLPToken.balanceOf(address(this)),\n        YearnVault(tokenAddresses[i])\n      );\n\n      //Approve yToken for minting\n      YearnVault(tokenAddresses[i]).safeIncreaseAllowance(\n        address(setBasicIssuanceModule),\n        YearnVault(tokenAddresses[i]).balanceOf(address(this))\n      );\n    }\n    //Get the minimum amount of butter that we can mint with our balances of yToken\n    uint256 butterAmount = (YearnVault(tokenAddresses[0]).balanceOf(address(this)) * 1e18) / quantities[0];\n\n    for (uint256 i = 1; i < tokenAddresses.length; i++) {\n      butterAmount = Math.min(\n        butterAmount,\n        (YearnVault(tokenAddresses[i]).balanceOf(address(this)) * 1e18) / quantities[i]\n      );\n    }\n\n    require(\n      butterAmount >=\n        getMinAmountToMint((batch.suppliedTokenBalance * threeCrvValue) / 1e18, setValue, slippage.mintBps),\n      \"slippage too high\"\n    );\n\n    //Mint Butter\n    setBasicIssuanceModule.issue(setToken, butterAmount, address(this));\n\n    //Save the minted amount Butter as claimable token for the batch\n    batch.claimableTokenBalance = butterAmount;\n\n    //Set claimable to true so users can claim their Butter\n    batch.claimable = true;\n\n    //Update lastMintedAt for cooldown calculations\n    lastMintedAt = block.timestamp;\n\n    emit BatchMinted(currentMintBatchId, batch.suppliedTokenBalance, butterAmount);\n\n    //Create the next mint batch\n    _generateNextBatch(currentMintBatchId, BatchType.Mint);\n  }\n\n  /**\n   * @notice Redeems Butter for 3CRV. This function goes through all the steps necessary to get 3CRV\n   * @dev This function reedeems Butter for the underlying yToken and deposits these yToken in curve Metapools for 3CRV\n   * @dev In order to get stablecoins from 3CRV we can use a zap to redeem 3CRV for stables in the curve tri-pool\n   * @dev handleKeeperIncentive checks if the msg.sender is a permissioned keeper and pays them a reward for calling this function (see KeeperIncentive.sol)\n   */\n  function batchRedeem() external whenNotPaused keeperIncentive(contractName, 1) {\n    Batch storage batch = batches[currentRedeemBatchId];\n\n    //Check if there was enough time between the last batch redemption and this attempt...\n    //...or if enough Butter was deposited to make the redemption worthwhile\n    //This is to prevent excessive gas consumption and costs as we will pay keeper to call this function\n    require(\n      ((block.timestamp - lastRedeemedAt >= processingThreshold.batchCooldown) ||\n        (batch.suppliedTokenBalance >= processingThreshold.redeemThreshold)) && batch.suppliedTokenBalance > 0,\n      \"can not execute batch redeem yet\"\n    );\n\n    //Check if the Batch got already processed\n    require(batch.claimable == false, \"already redeemed\");\n\n    //Get tokenAddresses for mapping of underlying\n    (address[] memory tokenAddresses, uint256[] memory quantities) = setBasicIssuanceModule\n      .getRequiredComponentUnitsForIssue(setToken, batch.suppliedTokenBalance);\n\n    //Allow setBasicIssuanceModule to use Butter\n    _setBasicIssuanceModuleAllowance(batch.suppliedTokenBalance);\n\n    //Redeem Butter for yToken\n    setBasicIssuanceModule.redeem(setToken, batch.suppliedTokenBalance, address(this));\n\n    //Check our balance of 3CRV since we could have some still around from previous batches\n    uint256 oldBalance = threeCrv.balanceOf(address(this));\n\n    for (uint256 i; i < tokenAddresses.length; i++) {\n      //Deposit yToken to receive crvLPToken\n      _withdrawFromYearn(YearnVault(tokenAddresses[i]).balanceOf(address(this)), YearnVault(tokenAddresses[i]));\n\n      uint256 crvLPTokenBalance = curvePoolTokenPairs[tokenAddresses[i]].crvLPToken.balanceOf(address(this));\n\n      //Deposit crvLPToken to receive 3CRV\n      _withdrawFromCurve(crvLPTokenBalance, curvePoolTokenPairs[tokenAddresses[i]].curveMetaPool);\n    }\n\n    //Save the redeemed amount of 3CRV as claimable token for the batch\n    batch.claimableTokenBalance = threeCrv.balanceOf(address(this)) - oldBalance;\n\n    require(\n      batch.claimableTokenBalance >=\n        getMinAmount3CrvFromRedeem(valueOfComponents(tokenAddresses, quantities), slippage.redeemBps),\n      \"slippage too high\"\n    );\n\n    emit BatchRedeemed(currentRedeemBatchId, batch.suppliedTokenBalance, batch.claimableTokenBalance);\n\n    //Set claimable to true so users can claim their Butter\n    batch.claimable = true;\n\n    //Update lastRedeemedAt for cooldown calculations\n    lastRedeemedAt = block.timestamp;\n\n    //Create the next redeem batch id\n    _generateNextBatch(currentRedeemBatchId, BatchType.Redeem);\n  }\n\n  /**\n   * @notice sets approval for contracts that require access to assets held by this contract\n   */\n  function setApprovals() external {\n    (address[] memory tokenAddresses, ) = setBasicIssuanceModule.getRequiredComponentUnitsForIssue(setToken, 1e18);\n\n    for (uint256 i; i < tokenAddresses.length; i++) {\n      IERC20 curveLpToken = curvePoolTokenPairs[tokenAddresses[i]].crvLPToken;\n      CurveMetapool curveMetapool = curvePoolTokenPairs[tokenAddresses[i]].curveMetaPool;\n      YearnVault yearnVault = YearnVault(tokenAddresses[i]);\n\n      _maxApprove(curveLpToken, address(curveMetapool));\n      _maxApprove(curveLpToken, address(yearnVault));\n      _maxApprove(threeCrv, address(curveMetapool));\n    }\n    _maxApprove(IERC20(address(setToken)), address(staking));\n  }\n\n  /**\n   * @notice returns the min amount of butter that should be minted given an amount of 3crv\n   * @dev this controls slippage in the minting process\n   */\n  function getMinAmountToMint(\n    uint256 _valueOfBatch,\n    uint256 _valueOfComponentsPerUnit,\n    uint256 _slippage\n  ) public pure returns (uint256) {\n    uint256 _mintAmount = (_valueOfBatch * 1e18) / _valueOfComponentsPerUnit;\n    uint256 _delta = (_mintAmount * _slippage) / 10_000;\n    return _mintAmount - _delta;\n  }\n\n  /**\n   * @notice returns the min amount of 3crv that should be redeemed given an amount of butter\n   * @dev this controls slippage in the redeeming process\n   */\n  function getMinAmount3CrvFromRedeem(uint256 _valueOfComponents, uint256 _slippage) public view returns (uint256) {\n    uint256 _threeCrvToReceive = (_valueOfComponents * 1e18) / threePool.get_virtual_price();\n    uint256 _delta = (_threeCrvToReceive * _slippage) / 10_000;\n    return _threeCrvToReceive - _delta;\n  }\n\n  /**\n   * @notice returns the value of butter in virtualPrice\n   */\n  function valueOfComponents(address[] memory _tokenAddresses, uint256[] memory _quantities)\n    public\n    view\n    returns (uint256)\n  {\n    uint256 value;\n    for (uint256 i = 0; i < _tokenAddresses.length; i++) {\n      value +=\n        (((YearnVault(_tokenAddresses[i]).pricePerShare() *\n          curvePoolTokenPairs[_tokenAddresses[i]].curveMetaPool.get_virtual_price()) / 1e18) * _quantities[i]) /\n        1e18;\n    }\n    return value;\n  }\n\n  /**\n   * @notice returns the value of an amount of 3crv in virtualPrice\n   */\n  function valueOf3Crv(uint256 _units) public view returns (uint256) {\n    return (_units * threePool.get_virtual_price()) / 1e18;\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /**\n   * @notice sets max allowance given a token and a spender\n   * @param _token the token which gets approved to be spend\n   * @param _spender the spender which gets a max allowance to spend `_token`\n   */\n  function _maxApprove(IERC20 _token, address _spender) internal {\n    _token.safeApprove(_spender, 0);\n    _token.safeApprove(_spender, type(uint256).max);\n  }\n\n  function _getPoolAllocationAndRatio(\n    address _component,\n    uint256 _quantity,\n    Batch memory _batch,\n    uint256 _setValue,\n    uint256 _threePoolPrice\n  ) internal view returns (uint256 poolAllocation, uint256 ratio) {\n    //Calculate the virtualPrice of one yToken\n    uint256 componentValuePerShare = (YearnVault(_component).pricePerShare() *\n      curvePoolTokenPairs[_component].curveMetaPool.get_virtual_price()) / 1e18;\n\n    //Calculate the value of quantity (of yToken) in virtualPrice\n    uint256 componentValuePerSet = (_quantity * componentValuePerShare) / 1e18;\n\n    //Calculate the value of leftover yToken in virtualPrice\n    uint256 componentValueHeldByContract = (YearnVault(_component).balanceOf(address(this)) * componentValuePerShare) /\n      1e18;\n\n    ratio = (componentValuePerSet * 1e18) / _setValue;\n\n    poolAllocation =\n      _getPoolAllocation((_batch.suppliedTokenBalance * _threePoolPrice) / 1e18, ratio) -\n      componentValueHeldByContract;\n\n    return (poolAllocation, ratio);\n  }\n\n  /**\n   * @notice returns the amount of 3CRV that should be allocated for a curveMetapool\n   * @param _balance the max amount of 3CRV that is available in this iteration\n   * @param _ratio the ratio of 3CRV needed to get enough yToken to mint butter\n   */\n  function _getPoolAllocation(uint256 _balance, uint256 _ratio) internal pure returns (uint256) {\n    return ((_balance * _ratio) / 1e18);\n  }\n\n  /**\n   * @notice sets allowance for basic issuance module\n   * @param _amount amount to approve\n   */\n  function _setBasicIssuanceModuleAllowance(uint256 _amount) internal {\n    setToken.safeApprove(address(setBasicIssuanceModule), 0);\n    setToken.safeApprove(address(setBasicIssuanceModule), _amount);\n  }\n\n  /**\n   * @notice makes sure only zapper or user can withdraw from accout_ and returns the recipient of the withdrawn token\n   * @param _account is the address which gets withdrawn from\n   * @dev returns recipient of the withdrawn funds\n   * @dev By default a user should set _account to their address\n   * @dev If zapper is used to withdraw and swap for a user the msg.sender will be zapper and _account is the user which we withdraw from. The zapper than sends the swapped funds afterwards to the user\n   */\n  function _getRecipient(address _account) internal view returns (address) {\n    //Make sure that only zapper can withdraw from someone else\n    require(_hasRole(keccak256(\"ButterZapper\"), msg.sender) || msg.sender == _account, \"you cant transfer other funds\");\n\n    //Set recipient per default to _account\n    address recipient = _account;\n\n    //set the recipient to zapper if its called by the zapper\n    if (_hasRole(keccak256(\"ButterZapper\"), msg.sender)) {\n      recipient = msg.sender;\n    }\n    return recipient;\n  }\n\n  /**\n   * @notice Generates the next batch id for new deposits\n   * @param _currentBatchId takes the current mint or redeem batch id\n   * @param _batchType BatchType of the newly created id\n   */\n  function _generateNextBatch(bytes32 _currentBatchId, BatchType _batchType) internal returns (bytes32) {\n    bytes32 id = _generateNextBatchId(_currentBatchId);\n    batchIds.push(id);\n    Batch storage batch = batches[id];\n    batch.batchType = _batchType;\n    batch.batchId = id;\n\n    if (BatchType.Mint == _batchType) {\n      currentMintBatchId = id;\n      batch.suppliedTokenAddress = address(threeCrv);\n      batch.claimableTokenAddress = address(setToken);\n    }\n    if (BatchType.Redeem == _batchType) {\n      currentRedeemBatchId = id;\n      batch.suppliedTokenAddress = address(setToken);\n      batch.claimableTokenAddress = address(threeCrv);\n    }\n    return id;\n  }\n\n  /**\n   * @notice Deposit either Butter or 3CRV in their respective batches\n   * @param _amount The amount of 3CRV or Butter a user is depositing\n   * @param _currentBatchId The current reedem or mint batch id to place the funds in the next batch to be processed\n   * @param _depositFor User that gets the shares attributed to (for use in zapper contract)\n   * @dev This function will be called by depositForMint or depositForRedeem and simply reduces code duplication\n   */\n  function _deposit(\n    uint256 _amount,\n    bytes32 _currentBatchId,\n    address _depositFor\n  ) internal {\n    Batch storage batch = batches[_currentBatchId];\n\n    //Add the new funds to the batch\n    batch.suppliedTokenBalance = batch.suppliedTokenBalance + _amount;\n    batch.unclaimedShares = batch.unclaimedShares + _amount;\n    accountBalances[_currentBatchId][_depositFor] = accountBalances[_currentBatchId][_depositFor] + _amount;\n\n    //Save the batchId for the user so they can be retrieved to claim the batch\n    if (\n      accountBatches[_depositFor].length == 0 ||\n      accountBatches[_depositFor][accountBatches[_depositFor].length - 1] != _currentBatchId\n    ) {\n      accountBatches[_depositFor].push(_currentBatchId);\n    }\n\n    emit Deposit(_depositFor, _amount);\n  }\n\n  /**\n   * @notice This function checks all requirements for claiming, updates batches and balances and returns the values needed for the final transfer of tokens\n   * @param _batchId Id of batch to claim from\n   * @param _claimFor User that gets the shares attributed to (for use in zapper contract)\n   */\n  function _prepareClaim(bytes32 _batchId, address _claimFor)\n    internal\n    returns (\n      address,\n      BatchType,\n      uint256,\n      uint256\n    )\n  {\n    Batch storage batch = batches[_batchId];\n    require(batch.claimable, \"not yet claimable\");\n\n    address recipient = _getRecipient(_claimFor);\n    uint256 accountBalance = accountBalances[_batchId][_claimFor];\n    require(accountBalance <= batch.unclaimedShares, \"claiming too many shares\");\n\n    //Calculate how many token will be claimed\n    uint256 tokenAmountToClaim = (batch.claimableTokenBalance * accountBalance) / batch.unclaimedShares;\n\n    //Subtract the claimed token from the batch\n    batch.claimableTokenBalance = batch.claimableTokenBalance - tokenAmountToClaim;\n    batch.unclaimedShares = batch.unclaimedShares - accountBalance;\n    accountBalances[_batchId][_claimFor] = 0;\n\n    return (recipient, batch.batchType, accountBalance, tokenAmountToClaim);\n  }\n\n  /**\n   * @notice Deposit 3CRV in a curve metapool for its LP-Token\n   * @param _amount The amount of 3CRV that gets deposited\n   * @param _curveMetapool The metapool where we want to provide liquidity\n   */\n  function _sendToCurve(uint256 _amount, CurveMetapool _curveMetapool) internal {\n    //Takes 3CRV and sends lpToken to this contract\n    //Metapools take an array of amounts with the exoctic stablecoin at the first spot and 3CRV at the second.\n    //The second variable determines the min amount of LP-Token we want to receive (slippage control)\n    _curveMetapool.add_liquidity([0, _amount], 0);\n  }\n\n  /**\n   * @notice Withdraws 3CRV for deposited crvLPToken\n   * @param _amount The amount of crvLPToken that get deposited\n   * @param _curveMetapool The metapool where we want to provide liquidity\n   */\n  function _withdrawFromCurve(uint256 _amount, CurveMetapool _curveMetapool) internal {\n    //Takes lp Token and sends 3CRV to this contract\n    //The second variable is the index for the token we want to receive (0 = exotic stablecoin, 1 = 3CRV)\n    //The third variable determines min amount of token we want to receive (slippage control)\n    _curveMetapool.remove_liquidity_one_coin(_amount, 1, 0);\n  }\n\n  /**\n   * @notice Deposits crvLPToken for yToken\n   * @param _amount The amount of crvLPToken that get deposited\n   * @param _yearnVault The yearn Vault in which we deposit\n   */\n  function _sendToYearn(uint256 _amount, YearnVault _yearnVault) internal {\n    //Mints yToken and sends them to msg.sender (this contract)\n    _yearnVault.deposit(_amount);\n  }\n\n  /**\n   * @notice Withdraw crvLPToken from yearn\n   * @param _amount The amount of crvLPToken which we deposit\n   * @param _yearnVault The yearn Vault in which we deposit\n   */\n  function _withdrawFromYearn(uint256 _amount, YearnVault _yearnVault) internal {\n    //Takes yToken and sends crvLPToken to this contract\n    _yearnVault.withdraw(_amount);\n  }\n\n  /**\n   * @notice Generates the next batch id for new deposits\n   * @param _currentBatchId takes the current mint or redeem batch id\n   */\n  function _generateNextBatchId(bytes32 _currentBatchId) internal view returns (bytes32) {\n    return keccak256(abi.encodePacked(block.timestamp, _currentBatchId));\n  }\n\n  /* ========== ADMIN ========== */\n\n  /**\n   * @notice This function allows the owner to change the composition of underlying token of the Butter\n   * @param _yTokenAddresses An array of addresses for the yToken needed to mint Butter\n   * @param _curvePoolTokenPairs An array structs describing underlying yToken, crvToken and curve metapool\n   */\n  function setCurvePoolTokenPairs(address[] memory _yTokenAddresses, CurvePoolTokenPair[] calldata _curvePoolTokenPairs)\n    public\n    onlyRole(DAO_ROLE)\n  {\n    _setCurvePoolTokenPairs(_yTokenAddresses, _curvePoolTokenPairs);\n  }\n\n  /**\n   * @notice This function defines which underlying token and pools are needed to mint a butter token\n   * @param _yTokenAddresses An array of addresses for the yToken needed to mint Butter\n   * @param _curvePoolTokenPairs An array structs describing underlying yToken, crvToken and curve metapool\n   * @dev since our calculations for minting just iterate through the index and match it with the quantities given by Set\n   * @dev we must make sure to align them correctly by index, otherwise our whole calculation breaks down\n   */\n  function _setCurvePoolTokenPairs(address[] memory _yTokenAddresses, CurvePoolTokenPair[] memory _curvePoolTokenPairs)\n    internal\n  {\n    emit CurveTokenPairsUpdated(_yTokenAddresses, _curvePoolTokenPairs);\n    for (uint256 i; i < _yTokenAddresses.length; i++) {\n      curvePoolTokenPairs[_yTokenAddresses[i]] = _curvePoolTokenPairs[i];\n    }\n  }\n\n  /**\n   * @notice Changes the the ProcessingThreshold\n   * @param _cooldown Cooldown in seconds\n   * @param _mintThreshold Amount of MIM necessary to mint immediately\n   * @param _redeemThreshold Amount of Butter necessary to mint immediately\n   * @dev The cooldown is the same for redeem and mint batches\n   */\n  function setProcessingThreshold(\n    uint256 _cooldown,\n    uint256 _mintThreshold,\n    uint256 _redeemThreshold\n  ) public onlyRole(DAO_ROLE) {\n    ProcessingThreshold memory newProcessingThreshold = ProcessingThreshold({\n      batchCooldown: _cooldown,\n      mintThreshold: _mintThreshold,\n      redeemThreshold: _redeemThreshold\n    });\n    emit ProcessingThresholdUpdated(processingThreshold, newProcessingThreshold);\n    processingThreshold = newProcessingThreshold;\n  }\n\n  /**\n   * @notice sets slippage for mint and redeem\n   * @param _mintSlippage amount in bps (e.g. 50 = 0.5%)\n   * @param _redeemSlippage amount in bps (e.g. 50 = 0.5%)\n   */\n  function setSlippage(uint256 _mintSlippage, uint256 _redeemSlippage) external onlyRole(DAO_ROLE) {\n    require(_mintSlippage <= 200 && _redeemSlippage <= 200, \"slippage too high\");\n    Slippage memory newSlippage = Slippage({ mintBps: _mintSlippage, redeemBps: _redeemSlippage });\n    emit SlippageUpdated(slippage, newSlippage);\n    slippage = newSlippage;\n  }\n\n  /**\n   * @notice Changes the redemption fee rate and the fee recipient\n   * @param _feeRate Redemption fee rate in basis points\n   * @param _recipient The recipient which receives these fees (Should be DAO treasury)\n   * @dev Per default both of these values are not set. Therefore a fee has to be explicitly be set with this function\n   */\n  function setRedemptionFee(uint256 _feeRate, address _recipient) external onlyRole(DAO_ROLE) {\n    require(_feeRate <= 100, \"dont get greedy\");\n    redemptionFee.rate = _feeRate;\n    redemptionFee.recipient = _recipient;\n    emit RedemptionFeeUpdated(_feeRate, _recipient);\n  }\n\n  /**\n   * @notice Claims all accumulated redemption fees in 3CRV\n   */\n  function claimRedemptionFee() external {\n    threeCrv.safeTransfer(redemptionFee.recipient, redemptionFee.accumulated);\n    redemptionFee.accumulated = 0;\n  }\n\n  /**\n   * @notice Allows the DAO to recover leftover yToken that have accumulated between pages and cant be used effectively in upcoming batches\n   * @dev This should only be used if there is a clear trend that a certain amount of yToken leftover wont be used in the minting process\n   * @param _yTokenAddress address of the yToken that should be recovered\n   * @param _amount amount of yToken that should recovered\n   */\n  function recoverLeftover(address _yTokenAddress, uint256 _amount) external onlyRole(DAO_ROLE) {\n    require(address(curvePoolTokenPairs[_yTokenAddress].curveMetaPool) != address(0), \"yToken doesnt exist\");\n    IERC20(_yTokenAddress).safeTransfer(_getContract(keccak256(\"Treasury\")), _amount);\n  }\n\n  /**\n   * @notice Toggles an address as Sweetheart (partner addresses that don't pay a redemption fee)\n   * @param _sweetheart The address that shall become/lose their sweetheart status\n   */\n  function updateSweetheart(address _sweetheart, bool _enabled) external onlyRole(DAO_ROLE) {\n    sweethearts[_sweetheart] = _enabled;\n    emit SweetheartUpdated(_sweetheart, _enabled);\n  }\n\n  /**\n   * @notice Pauses the contract.\n   * @dev All function with the modifer `whenNotPaused` cant be called anymore. Namly deposits and mint/redeem\n   */\n  function pause() external onlyRole(DAO_ROLE) {\n    _pause();\n  }\n\n  /**\n   * @notice Unpauses the contract.\n   * @dev All function with the modifer `whenNotPaused` cant be called anymore. Namly deposits and mint/redeem\n   */\n  function unpause() external onlyRole(DAO_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Updates the staking contract\n   */\n  function setStaking(address _staking) external onlyRole(DAO_ROLE) {\n    emit StakingUpdated(address(staking), _staking);\n    staking = IStaking(_staking);\n  }\n\n  function _getContract(bytes32 _name)\n    internal\n    view\n    override(ACLAuth, KeeperIncentivized, ContractRegistryAccess)\n    returns (address)\n  {\n    return super._getContract(_name);\n  }\n}\n"
    },
    "contracts/core/interfaces/IACLRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.0\n\npragma solidity >0.6.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IACLRegistry {\n  /**\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n   *\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n   * {RoleAdminChanged} not being emitted signaling this.\n   *\n   * _Available since v3.1._\n   */\n  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n  /**\n   * @dev Emitted when `account` is granted `role`.\n   *\n   * `sender` is the account that originated the contract call, an admin role\n   * bearer except when using {AccessControl-_setupRole}.\n   */\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n  /**\n   * @dev Emitted when `account` is revoked `role`.\n   *\n   * `sender` is the account that originated the contract call:\n   *   - if using `revokeRole`, it is the admin role bearer\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n   */\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  /**\n   * @dev Returns `true` if `account` has been granted `permission`.\n   */\n  function hasPermission(bytes32 permission, address account) external view returns (bool);\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) external;\n\n  function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n\n  function grantPermission(bytes32 permission, address account) external;\n\n  function revokePermission(bytes32 permission) external;\n\n  function requireApprovedContractOrEOA(address account) external view;\n\n  function requireRole(bytes32 role, address account) external view;\n\n  function requirePermission(bytes32 permission, address account) external view;\n\n  function isRoleAdmin(bytes32 role, address account) external view;\n}\n"
    },
    "contracts/core/interfaces/IContractRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.0\n\npragma solidity >0.6.0;\n\n/**\n * @dev External interface of ContractRegistry.\n */\ninterface IContractRegistry {\n  function getContract(bytes32 _name) external view returns (address);\n}\n"
    },
    "contracts/core/interfaces/IKeeperIncentive.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.0\n\npragma solidity ^0.8.0;\n\ninterface IKeeperIncentive {\n  function handleKeeperIncentive(\n    bytes32 _contractName,\n    uint8 _i,\n    address _keeper\n  ) external;\n}\n"
    },
    "contracts/core/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.0\n\npragma solidity ^0.8.0;\n\ninterface IStaking {\n  function balanceOf(address account) external view returns (uint256);\n\n  function stake(uint256 amount) external;\n\n  function stakeFor(uint256 amount, address account) external;\n\n  function withdraw(uint256 amount) external;\n\n  function notifyRewardAmount(uint256 reward) external;\n}\n"
    },
    "contracts/core/utils/ACLAuth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IACLRegistry.sol\";\n\n/**\n *  @notice Provides modifiers and internal functions for interacting with the `ACLRegistry`\n *  @dev Derived contracts using `ACLAuth` must also inherit `ContractRegistryAccess`\n *   and override `_getContract`.\n */\nabstract contract ACLAuth {\n  /**\n   *  @dev Equal to keccak256(\"Keeper\")\n   */\n  bytes32 internal constant KEEPER_ROLE = 0x4f78afe9dfc9a0cb0441c27b9405070cd2a48b490636a7bdd09f355e33a5d7de;\n\n  /**\n   *  @dev Equal to keccak256(\"DAO\")\n   */\n  bytes32 internal constant DAO_ROLE = 0xd0a4ad96d49edb1c33461cebc6fb2609190f32c904e3c3f5877edb4488dee91e;\n\n  /**\n   *  @dev Equal to keccak256(\"ApprovedContract\")\n   */\n  bytes32 internal constant APPROVED_CONTRACT_ROLE = 0xfb639edf4b4a4724b8b9fb42a839b712c82108c1edf1beb051bcebce8e689dc4;\n\n  /**\n   *  @dev Equal to keccak256(\"ACLRegistry\")\n   */\n  bytes32 internal constant ACL_REGISTRY_ID = 0x15fa0125f52e5705da1148bfcf00974823c4381bee4314203ede255f9477b73e;\n\n  /**\n   *  @notice Require that `msg.sender` has given role\n   *  @param role bytes32 role ID\n   */\n  modifier onlyRole(bytes32 role) {\n    _requireRole(role);\n    _;\n  }\n\n  /**\n   *  @notice Require that `msg.sender` has given permission\n   *  @param role bytes32 permission ID\n   */\n  modifier onlyPermission(bytes32 role) {\n    _requirePermission(role);\n    _;\n  }\n\n  /**\n   *  @notice Require that `msg.sender` has the `ApprovedContract` role or is an EOA\n   *  @dev This EOA check requires that `tx.origin == msg.sender` if caller does not have the `ApprovedContract` role.\n   *  This limits compatibility with contract-based wallets for functions protected with this modifier.\n   */\n  modifier onlyApprovedContractOrEOA() {\n    _requireApprovedContractOrEOA(msg.sender);\n    _;\n  }\n\n  /**\n   *  @notice Check whether a given account has been granted this bytes32 role\n   *  @param role bytes32 role ID\n   *  @param account address of account to check for role\n   *  @return Whether account has been granted specified role.\n   */\n  function _hasRole(bytes32 role, address account) internal view returns (bool) {\n    return _aclRegistry().hasRole(role, account);\n  }\n\n  /**\n   *  @notice Require that `msg.sender` has given role\n   *  @param role bytes32 role ID\n   */\n  function _requireRole(bytes32 role) internal view {\n    _requireRole(role, msg.sender);\n  }\n\n  /**\n   *  @notice Require that given account has specified role\n   *  @param role bytes32 role ID\n   *  @param account address of account to check for role\n   */\n  function _requireRole(bytes32 role, address account) internal view {\n    _aclRegistry().requireRole(role, account);\n  }\n\n  /**\n   *  @notice Check whether a given account has been granted this bytes32 permission\n   *  @param permission bytes32 permission ID\n   *  @param account address of account to check for permission\n   *  @return Whether account has been granted specified permission.\n   */\n  function _hasPermission(bytes32 permission, address account) internal view returns (bool) {\n    return _aclRegistry().hasPermission(permission, account);\n  }\n\n  /**\n   *  @notice Require that `msg.sender` has specified permission\n   *  @param permission bytes32 permission ID\n   */\n  function _requirePermission(bytes32 permission) internal view {\n    _requirePermission(permission, msg.sender);\n  }\n\n  /**\n   *  @notice Require that given account has specified permission\n   *  @param permission bytes32 permission ID\n   *  @param account address of account to check for permission\n   */\n  function _requirePermission(bytes32 permission, address account) internal view {\n    _aclRegistry().requirePermission(permission, account);\n  }\n\n  /**\n   *  @notice Require that `msg.sender` has the `ApprovedContract` role or is an EOA\n   *  @dev This EOA check requires that `tx.origin == msg.sender` if caller does not have the `ApprovedContract` role.\n   *  This limits compatibility with contract-based wallets for functions protected with this modifier.\n   */\n  function _requireApprovedContractOrEOA() internal view {\n    _requireApprovedContractOrEOA(msg.sender);\n  }\n\n  /**\n   *  @notice Require that `account` has the `ApprovedContract` role or is an EOA\n   *  @param account address of account to check for role/EOA\n   *  @dev This EOA check requires that `tx.origin == msg.sender` if caller does not have the `ApprovedContract` role.\n   *  This limits compatibility with contract-based wallets for functions protected with this modifier.\n   */\n  function _requireApprovedContractOrEOA(address account) internal view {\n    _aclRegistry().requireApprovedContractOrEOA(account);\n  }\n\n  /**\n   *  @notice Return an IACLRegistry interface to the registered ACLRegistry contract\n   *  @return IACLRegistry interface to ACLRegistry contract\n   */\n  function _aclRegistry() internal view returns (IACLRegistry) {\n    return IACLRegistry(_getContract(ACL_REGISTRY_ID));\n  }\n\n  /**\n   *  @notice Get a contract address by name from the contract registry\n   *  @param _name bytes32 contract name\n   *  @return contract address\n   *  @dev Users of this abstract contract should also inherit from `ContractRegistryAccess`\n   *   and override `_getContract` in their implementation.\n   */\n  function _getContract(bytes32 _name) internal view virtual returns (address);\n}\n"
    },
    "contracts/core/utils/ContractRegistryAccess.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IContractRegistry.sol\";\n\n/**\n *  @notice Provides an internal `_getContract` helper function to access the `ContractRegistry`\n */\nabstract contract ContractRegistryAccess {\n  IContractRegistry internal _contractRegistry;\n\n  constructor(IContractRegistry contractRegistry_) {\n    _contractRegistry = contractRegistry_;\n  }\n\n  /**\n   *  @notice Get a contract address by bytes32 name\n   *  @param _name bytes32 contract name\n   *  @dev contract name should be a keccak256 hash of the name string, e.g. `keccak256(\"ContractName\")`\n   *  @return contract address\n   */\n  function _getContract(bytes32 _name) internal view virtual returns (address) {\n    return _contractRegistry.getContract(_name);\n  }\n}\n"
    },
    "contracts/core/utils/KeeperIncentivized.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IKeeperIncentive.sol\";\n\n/**\n *  @notice Provides modifiers and internal functions for processing keeper incentives\n *  @dev Derived contracts using `KeeperIncentivized` must also inherit `ContractRegistryAccess`\n *   and override `_getContract`.\n */\nabstract contract KeeperIncentivized {\n  /**\n   *  @notice Role ID for KeeperIncentive\n   *  @dev Equal to keccak256(\"KeeperIncentive\")\n   */\n  bytes32 public constant KEEPER_INCENTIVE = 0x35ed2e1befd3b2dcf1ec7a6834437fa3212881ed81fd3a13dc97c3438896e1ba;\n\n  /**\n   *  @notice Process the specified incentive with `msg.sender` as the keeper address\n   *  @param _contractName bytes32 name of calling contract\n   *  @param _index uint8 incentive ID\n   */\n  modifier keeperIncentive(bytes32 _contractName, uint8 _index) {\n    _handleKeeperIncentive(_contractName, _index, msg.sender);\n    _;\n  }\n\n  /**\n   *  @notice Process a keeper incentive\n   *  @param _contractName bytes32 name of calling contract\n   *  @param _index uint8 incentive ID\n   *  @param _keeper address of keeper to reward\n   */\n  function _handleKeeperIncentive(\n    bytes32 _contractName,\n    uint8 _index,\n    address _keeper\n  ) internal {\n    _keeperIncentive().handleKeeperIncentive(_contractName, _index, _keeper);\n  }\n\n  /**\n   *  @notice Return an IKeeperIncentive interface to the registered KeeperIncentive contract\n   *  @return IKeeperIncentive keeper incentive interface\n   */\n  function _keeperIncentive() internal view returns (IKeeperIncentive) {\n    return IKeeperIncentive(_getContract(KEEPER_INCENTIVE));\n  }\n\n  /**\n   *  @notice Get a contract address by name from the contract registry\n   *  @param _name bytes32 contract name\n   *  @return contract address\n   *  @dev Users of this abstract contract should also inherit from `ContractRegistryAccess`\n   *   and override `_getContract` in their implementation.\n   */\n  function _getContract(bytes32 _name) internal view virtual returns (address);\n}\n"
    },
    "contracts/externals/interfaces/BasicIssuanceModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.0\n\npragma solidity ^0.8.0;\n\nimport \"./ISetToken.sol\";\n\ninterface BasicIssuanceModule {\n  function getRequiredComponentUnitsForIssue(ISetToken _setToken, uint256 _quantity)\n    external\n    view\n    returns (address[] memory, uint256[] memory);\n\n  function issue(\n    ISetToken _setToken,\n    uint256 _quantity,\n    address _to\n  ) external;\n\n  function redeem(\n    ISetToken _setToken,\n    uint256 _quantity,\n    address _to\n  ) external;\n}\n"
    },
    "contracts/externals/interfaces/CurveContracts.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface CurveAddressProvider {\n  function get_registry() external view returns (address);\n}\n\ninterface CurveRegistry {\n  function get_pool_from_lp_token(address lp_token) external view returns (address);\n}\n\ninterface CurveMetapool {\n  function get_virtual_price() external view returns (uint256);\n\n  function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amounts) external returns (uint256);\n\n  function add_liquidity(\n    uint256[2] calldata _amounts,\n    uint256 _min_mint_amounts,\n    address _receiver\n  ) external returns (uint256);\n\n  function remove_liquidity_one_coin(\n    uint256 amount,\n    int128 i,\n    uint256 min_underlying_amount\n  ) external returns (uint256);\n\n  function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);\n}\n\ninterface ThreeCrv is IERC20 {}\n\ninterface CrvLPToken is IERC20 {}\n"
    },
    "contracts/externals/interfaces/ISetToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// Docgen-SOLC: 0.8.0\n\n/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title ISetToken\n * @author Set Protocol\n *\n * Interface for operating with SetTokens.\n */\ninterface ISetToken is IERC20 {\n  /* ============ Enums ============ */\n\n  enum ModuleState {\n    NONE,\n    PENDING,\n    INITIALIZED\n  }\n\n  /* ============ Structs ============ */\n  /**\n   * The base definition of a SetToken Position\n   *\n   * @param component           Address of token in the Position\n   * @param module              If not in default state, the address of associated module\n   * @param unit                Each unit is the # of components per 10^18 of a SetToken\n   * @param positionState       Position ENUM. Default is 0; External is 1\n   * @param data                Arbitrary data\n   */\n  struct Position {\n    address component;\n    address module;\n    int256 unit;\n    uint8 positionState;\n    bytes data;\n  }\n\n  /**\n   * A struct that stores a component's cash position details and external positions\n   * This data structure allows O(1) access to a component's cash position units and\n   * virtual units.\n   *\n   * @param virtualUnit               Virtual value of a component's DEFAULT position. Stored as virtual for efficiency\n   *                                  updating all units at once via the position multiplier. Virtual units are achieved\n   *                                  by dividing a \"real\" value by the \"positionMultiplier\"\n   * @param componentIndex\n   * @param externalPositionModules   List of external modules attached to each external position. Each module\n   *                                  maps to an external position\n   * @param externalPositions         Mapping of module => ExternalPosition struct for a given component\n   */\n  struct ComponentPosition {\n    int256 virtualUnit;\n    address[] externalPositionModules;\n    mapping(address => ExternalPosition) externalPositions;\n  }\n\n  /**\n   * A struct that stores a component's external position details including virtual unit and any\n   * auxiliary data.\n   *\n   * @param virtualUnit       Virtual value of a component's EXTERNAL position.\n   * @param data              Arbitrary data\n   */\n  struct ExternalPosition {\n    int256 virtualUnit;\n    bytes data;\n  }\n\n  /* ============ Functions ============ */\n\n  function addComponent(address _component) external;\n\n  function removeComponent(address _component) external;\n\n  function editDefaultPositionUnit(address _component, int256 _realUnit) external;\n\n  function addExternalPositionModule(address _component, address _positionModule) external;\n\n  function removeExternalPositionModule(address _component, address _positionModule) external;\n\n  function editExternalPositionUnit(\n    address _component,\n    address _positionModule,\n    int256 _realUnit\n  ) external;\n\n  function editExternalPositionData(\n    address _component,\n    address _positionModule,\n    bytes calldata _data\n  ) external;\n\n  function invoke(\n    address _target,\n    uint256 _value,\n    bytes calldata _data\n  ) external returns (bytes memory);\n\n  function editPositionMultiplier(int256 _newMultiplier) external;\n\n  function mint(address _account, uint256 _quantity) external;\n\n  function burn(address _account, uint256 _quantity) external;\n\n  function lock() external;\n\n  function unlock() external;\n\n  function addModule(address _module) external;\n\n  function removeModule(address _module) external;\n\n  function initializeModule() external;\n\n  function setManager(address _manager) external;\n\n  function manager() external view returns (address);\n\n  function moduleStates(address _module) external view returns (ModuleState);\n\n  function getModules() external view returns (address[] memory);\n\n  function getDefaultPositionRealUnit(address _component) external view returns (int256);\n\n  function getExternalPositionRealUnit(address _component, address _positionModule) external view returns (int256);\n\n  function getComponents() external view returns (address[] memory);\n\n  function getExternalPositionModules(address _component) external view returns (address[] memory);\n\n  function getExternalPositionData(address _component, address _positionModule) external view returns (bytes memory);\n\n  function isExternalPositionModule(address _component, address _module) external view returns (bool);\n\n  function isComponent(address _component) external view returns (bool);\n\n  function positionMultiplier() external view returns (int256);\n\n  function getPositions() external view returns (Position[] memory);\n\n  function getTotalComponentRealUnits(address _component) external view returns (int256);\n\n  function isInitializedModule(address _module) external view returns (bool);\n\n  function isPendingModule(address _module) external view returns (bool);\n\n  function isLocked() external view returns (bool);\n}\n"
    },
    "contracts/externals/interfaces/YearnVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.6.0\n\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface YearnVault is IERC20 {\n  function token() external view returns (address);\n\n  function deposit(uint256 amount) external;\n\n  function withdraw(uint256 amount) external;\n\n  function pricePerShare() external view returns (uint256);\n}\n"
    }
  }
}}