{{
  "language": "Solidity",
  "sources": {
    "./contracts/oracles/OpynOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport {IOracle} from \"../interfaces/GammaInterface.sol\";\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\n\ncontract OpynOracle is IPriceOracle {\n    /// @dev base decimals\n    uint256 public constant override decimals = 8;\n\n    /// @notice Gamma Protocol oracle\n    IOracle public immutable oracle;\n\n    /// @notice Asset to get the price of\n    address public immutable asset;\n\n    constructor(address _oracle, address _asset) {\n        require(_oracle != address(0), \"!oracle\");\n        require(_asset != address(0), \"!asset\");\n\n        oracle = IOracle(_oracle);\n        asset = _asset;\n    }\n\n    function latestAnswer() external view override returns (uint256) {\n        return oracle.getPrice(asset);\n    }\n}\n"
    },
    "./contracts/interfaces/GammaInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nlibrary GammaTypes {\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\n    struct Vault {\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\n        address[] shortOtokens;\n        // addresses of oTokens a user has bought and deposited in this vault\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral\n        // in order to write oTokens against (i.e. in spreads)\n        address[] longOtokens;\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\n        address[] collateralAssets;\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\n        uint256[] shortAmounts;\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\n        uint256[] longAmounts;\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\n        uint256[] collateralAmounts;\n    }\n}\n\ninterface IOtoken {\n    function underlyingAsset() external view returns (address);\n\n    function strikeAsset() external view returns (address);\n\n    function collateralAsset() external view returns (address);\n\n    function strikePrice() external view returns (uint256);\n\n    function expiryTimestamp() external view returns (uint256);\n\n    function isPut() external view returns (bool);\n}\n\ninterface IOtokenFactory {\n    function getOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address);\n\n    function createOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external returns (address);\n\n    function getTargetOtokenAddress(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address);\n\n    event OtokenCreated(\n        address tokenAddress,\n        address creator,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    );\n}\n\ninterface IController {\n    // possible actions that can be performed\n    enum ActionType {\n        OpenVault,\n        MintShortOption,\n        BurnShortOption,\n        DepositLongOption,\n        WithdrawLongOption,\n        DepositCollateral,\n        WithdrawCollateral,\n        SettleVault,\n        Redeem,\n        Call,\n        Liquidate\n    }\n\n    struct ActionArgs {\n        // type of action that is being performed on the system\n        ActionType actionType;\n        // address of the account owner\n        address owner;\n        // address which we move assets from or to (depending on the action type)\n        address secondAddress;\n        // asset that is to be transfered\n        address asset;\n        // index of the vault that is to be modified (if any)\n        uint256 vaultId;\n        // amount of asset that is to be transfered\n        uint256 amount;\n        // each vault can hold multiple short / long / collateral assets\n        // but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // any other data that needs to be passed in for arbitrary function calls\n        bytes data;\n    }\n\n    struct RedeemArgs {\n        // address to which we pay out the oToken proceeds\n        address receiver;\n        // oToken that is to be redeemed\n        address otoken;\n        // amount of oTokens that is to be redeemed\n        uint256 amount;\n    }\n\n    function getPayout(address _otoken, uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    function operate(ActionArgs[] calldata _actions) external;\n\n    function getAccountVaultCounter(address owner)\n        external\n        view\n        returns (uint256);\n\n    function oracle() external view returns (address);\n\n    function getVault(address _owner, uint256 _vaultId)\n        external\n        view\n        returns (GammaTypes.Vault memory);\n\n    function getProceed(address _owner, uint256 _vaultId)\n        external\n        view\n        returns (uint256);\n\n    function isSettlementAllowed(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        uint256 _expiry\n    ) external view returns (bool);\n}\n\ninterface IOracle {\n    function setAssetPricer(address _asset, address _pricer) external;\n\n    function updateAssetPricer(address _asset, address _pricer) external;\n\n    function getPrice(address _asset) external view returns (uint256);\n}\n"
    },
    "./contracts/interfaces/IPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\ninterface IPriceOracle {\n    function decimals() external view returns (uint256 _decimals);\n\n    function latestAnswer() external view returns (uint256 price);\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}