{{
  "language": "Solidity",
  "sources": {
    "contracts/FactoryV1.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IERC20.sol\";\nimport \"@beandao/contracts/interfaces/IERC165.sol\";\nimport \"@beandao/contracts/library/Address.sol\";\nimport \"@beandao/contracts/library/BeaconDeployer.sol\";\nimport {Ownership, IERC173} from \"@beandao/contracts/library/Ownership.sol\";\nimport {BeaconProxyDeployer} from \"@beandao/contracts/library/BeaconProxyDeployer.sol\";\nimport {MinimalProxyDeployer} from \"@beandao/contracts/library/MinimalProxyDeployer.sol\";\nimport {Multicall, IMulticall} from \"@beandao/contracts/library/Multicall.sol\";\nimport \"./IFactory.sol\";\n\n/**\n * @title Factory V1\n * @author yoonsung.eth\n * @notice Abstract reusable contract into template and deploy them in small sizes `minimal proxy` and `beacon proxy`.\n * This contract can receive a fee lower than the deploy cost, and registered addresses do not have to pay the fee.\n * Beacon is managed in this contract, it can be useful if you need a scalable upgrade through the `beacon proxy`.\n * @dev The template to be registered may or may not have an `initialize` function.\n * However, at least a ERC173 and multicall for directed at self must be implemented.\n */\ncontract FactoryV1 is Ownership, Multicall, IFactory {\n    using Address for address;\n\n    /**\n     * @notice template key for template info.\n     */\n    mapping(bytes32 => TemplateInfo) public templates;\n\n    /**\n     * @notice registered template for nonce.\n     */\n    mapping(address => uint256) private nonceForTemplate;\n\n    /**\n     * @notice template count.\n     */\n    uint256 public nonce = 1;\n\n    /**\n     * @notice base fee\n     */\n    uint256 public baseFee;\n\n    /**\n     * @notice fee collector\n     */\n    address payable public feeTo;\n\n    /**\n     * @notice requiring on deploy, allowlist contract.\n     * @param feeAmount basic fee for ether amount\n     * @param feeToAddr fee collector address\n     */\n    constructor(uint256 feeAmount, address payable feeToAddr) {\n        baseFee = feeAmount;\n        feeTo = feeToAddr;\n        nonceForTemplate[address(0)] = type(uint256).max;\n    }\n\n    /**\n     * @notice template id를 통해서 minimal proxy와 minimal beacon proxy를 배포하는 함수.\n     * @dev 일반적으로 배포되는 컨트랙트와 같이 컨트랙트가 생성될 때 초기화 함수를 실행해야 한다면, initializationCallData에 호출할 함수를\n     * serialize하여 주입하여야 합니다. 컨트랙트 소유권을 별도로 관리해야하는 경우 multicall을 통해서 명시적인 소유권 이전이 되어야 합니다.\n     * @param templateId 배포할 컨트랙트의 template id\n     * @param isBeacon 비콘으로 배포해야 할 것인지 결정하는 인자.\n     * @param initializationCallData 컨트랙트가 생성될 때 호출할 직렬화된 초기화 함수 정보\n     * @param calls 컨트랙트가 배포된 이후, 필요한 일련의 함수 호출 정보\n     */\n    function deploy(\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed) {\n        // 템플릿을 배포하기 위한 수수료가 적정 수준인지 확인.\n        require(baseFee <= msg.value || owner == msg.sender, \"Factory/Incorrect-amounts\");\n        // 수수료 전송\n        feeTransfer(feeTo, msg.value);\n        // 배포할 템플릿의 정보\n        TemplateInfo memory tmp = templates[templateId];\n\n        deployed = isBeacon\n            ? BeaconProxyDeployer.deploy(tmp.btemplate, initializationCallData)\n            : MinimalProxyDeployer.deploy(tmp.template, initializationCallData);\n\n        // 부수적으로 호출할 데이터가 있다면, 배포된 컨트랙트에 추가적인 call을 할 수 있음.\n        if (calls.length > 0) IMulticall(deployed).multicall(calls);\n        // 이벤트 호출\n        emit Deployed(deployed, msg.sender);\n    }\n\n    /**\n     * @notice template id와 외부에서 관리되는 seed를 통해서 minimal proxy와 minimal beacon proxy를 배포하는 함수.\n     * @dev 일반적으로 배포되는 컨트랙트와 같이 컨트랙트가 생성될 때 초기화 함수를 실행해야 한다면, initializationCallData에 호출할 함수를\n     * serialize하여 주입하여야 합니다. 컨트랙트 소유권을 별도로 관리해야하는 경우 multicall을 통해서 명시적인 소유권 이전이 되어야 합니다.\n     * @param seed 컨트랙트 주소 확정에 필요한 외부 seed\n     * @param isBeacon 비콘으로 배포해야 할 것인지 결정하는 인자.\n     * @param templateId 배포할 컨트랙트의 template id\n     * @param initializationCallData 컨트랙트가 생성될 때 호출할 직렬화된 초기화 함수 정보\n     * @param calls 컨트랙트가 배포된 이후, 필요한 일련의 함수 호출 정보\n     */\n    function deployWithSeed(\n        string memory seed,\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed) {\n        // 템플릿을 배포하기 위한 수수료가 적정 수준인지 확인.\n        require(baseFee <= msg.value || owner == msg.sender, \"Factory/Incorrect-amounts\");\n        // 수수료 전송\n        feeTransfer(feeTo, msg.value);\n        // 배포할 템플릿의 정보\n        TemplateInfo memory tmp = templates[templateId];\n\n        deployed = isBeacon\n            ? BeaconProxyDeployer.deploy(seed, tmp.btemplate, initializationCallData)\n            : MinimalProxyDeployer.deploy(seed, tmp.template, initializationCallData);\n\n        // 부수적으로 호출할 데이터가 있다면, 배포된 컨트랙트에 추가적인 call을 할 수 있음.\n        if (calls.length > 0) IMulticall(deployed).multicall(calls);\n        // 이벤트 호출\n        emit Deployed(deployed, msg.sender);\n    }\n\n    /**\n     * @notice template id와 초기화 데이터 통해서 minimal proxy와 minimal beacon proxy로 배포할 주소를 미리 파악하는 함수\n     * @dev 연결된 지갑 주소에 따라 생성될 지갑 주소가 변경되므로, 연결되어 있는 주소를 필수로 확인하여야 합니다.\n     * @param isBeacon 비콘으로 배포해야 할 것인지 결정하는 인자.\n     * @param templateId 배포할 컨트랙트의 template id\n     * @param initializationCallData 컨트랙트가 생성될 때 호출할 직렬화된 초기화 함수 정보\n     */\n    function compute(\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData\n    ) external view returns (address deployable) {\n        TemplateInfo memory tmp = templates[templateId];\n        deployable = isBeacon\n            ? BeaconProxyDeployer.calculateAddress(tmp.btemplate, initializationCallData)\n            : MinimalProxyDeployer.calculateAddress(tmp.template, initializationCallData);\n    }\n\n    /**\n     * @notice template id와 Seed 문자열, 초기화 데이터 통해서 minimal proxy와 minimal beacon proxy로 배포할 주소를 미리 파악하는 함수\n     * @dev 연결된 지갑 주소에 따라 생성될 지갑 주소가 변경되므로, 연결되어 있는 주소를 필수로 확인하여야 합니다.\n     * @param seed 컨트랙트에 사용할 seed 문자열\n     * @param isBeacon 비콘으로 배포해야 할 것인지 결정하는 인자.\n     * @param templateId 배포할 컨트랙트의 template id\n     * @param initializationCallData 컨트랙트가 생성될 때 호출할 직렬화된 초기화 함수 정보\n     */\n    function computeWithSeed(\n        string memory seed,\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData\n    ) external view returns (address deployable) {\n        TemplateInfo memory tmp = templates[templateId];\n        deployable = isBeacon\n            ? BeaconProxyDeployer.calculateAddress(seed, tmp.btemplate, initializationCallData)\n            : MinimalProxyDeployer.calculateAddress(seed, tmp.template, initializationCallData);\n    }\n\n    /**\n     * @notice Factori.eth에 등록되지 않은 컨트랙트를 Template로 하여 Minimal Proxy로 배포합니다.\n     * @param templateAddr 템플릿으로 사용할 이미 배포된 컨트랙트 주소\n     * @param initializationCallData 배포되면서 호출되어야 하는 초기화 함수\n     * @param calls 초기화 함수 이외에, 호출되어야 하는 함수들의 배열\n     */\n    function clone(\n        address templateAddr,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed) {\n        require(nonceForTemplate[templateAddr] == 0, \"Factory/Registered-Template\");\n        // 템플릿을 배포하기 위한 수수료가 적정 수준인지 확인.\n        require(baseFee == msg.value || owner == msg.sender, \"Factory/Incorrect-amounts\");\n        // 수수료 전송\n        feeTransfer(feeTo, msg.value);\n        deployed = MinimalProxyDeployer.deploy(templateAddr, initializationCallData);\n        if (calls.length > 0) IMulticall(deployed).multicall(calls);\n    }\n\n    /**\n     * @notice Factori.eth에 등록되지 않은 컨트랙트를 Template로 하여 minimal proxy로 배포할 주소를 미리 파악하는 함수\n     * @dev 연결된 지갑 주소에 따라 생성될 지갑 주소가 변경되므로, 연결되어 있는 주소를 필수로 확인하여야 합니다.\n     * @param templateAddr 배포할 컨트랙트의 template id\n     * @param initializationCallData 컨트랙트가 생성될 때 호출할 직렬화된 초기화 함수 정보\n     */\n    function computeClone(address templateAddr, bytes memory initializationCallData)\n        external\n        view\n        returns (address deployable)\n    {\n        deployable = MinimalProxyDeployer.calculateAddress(templateAddr, initializationCallData);\n    }\n\n    /**\n     * @notice template id에 따라서 컨트랙트를 배포하기 위한 필요 가격을 가져오는 함\n     * @dev 연결된 지갑 주소에 따라 생성될 지갑 주소가 변경되므로, 연결되어 있는 주소를 필수로 확인하여야 합니다.\n     * @return price 이더리움으로 구성된 값을 가짐.\n     */\n    function getPrice() external view returns (uint256 price) {\n        price = baseFee;\n    }\n\n    /**\n     * @notice 템플릿으로 사용되기 적합한 인터페이스가 구현된 컨트랙트를 템플릿으로 가격과 함께 등록함.\n     * @dev 같은 템플릿이 비콘과, 일반적인 템플릿으로 등록될 수 있습니다. 따라서 선택적으로 사용 가능합니다.\n     * @param templateAddr 템플릿으로 사용될 컨트랙트의 주소\n     */\n    function addTemplate(address templateAddr) external onlyOwner {\n        require(nonceForTemplate[templateAddr] == 0, \"Factory/Non-Valid\");\n        bytes32 key = keccak256(abi.encode(templateAddr, nonce));\n        address beaconAddr = BeaconDeployer.deploy(templateAddr);\n        templates[key] = TemplateInfo({template: templateAddr, btemplate: beaconAddr});\n        nonceForTemplate[templateAddr] = nonce++;\n        emit NewTemplate(key, templateAddr, beaconAddr);\n    }\n\n    /**\n     * @notice 등록된 템플릿의 정보를 변경하는 함수, 비콘인 경우에는 템플릿을 업데이트 할 수 있으나 비콘이 아니라면 업데이트 불가능.\n     * @param key 업데이트 될 템플릿의 아이디\n     * @param templateAddr 비콘일 경우 템플릿 주소, 템플릿 소유주 주소를 순서대로 인코딩\n     */\n    function updateTemplate(bytes32 key, address templateAddr) external onlyOwner {\n        require(templateAddr != address(0), \"Factory/Non-Valid\");\n        require(nonceForTemplate[templateAddr] == 0, \"Factory/registered-before\");\n        require(templateAddr.isContract(), \"Factory/is-not-Contract\");\n        TemplateInfo memory tmp = templates[key];\n        tmp.template = templateAddr;\n        (bool success, ) = tmp.btemplate.call(abi.encode(templateAddr));\n        assert(success);\n        templates[key] = tmp;\n        emit UpdatedTemplate(key, tmp.template);\n    }\n\n    /**\n     * @notice 등록된 템플릿을 삭제하는 함수\n     * @param key 삭제될 템플릿의 아이디\n     */\n    function removeTemplate(bytes32 key) external onlyOwner {\n        TemplateInfo memory tmp = templates[key];\n        require(tmp.template != address(0), \"Factory/Non-Exist\");\n        delete templates[key];\n        emit DeletedTemplate(key);\n    }\n\n    /**\n     * @notice 고정 수수료를 변경\n     * @param newFee 변경된 수수료\n     */\n    function changeFee(uint256 newFee) external onlyOwner {\n        uint256 prevFee = baseFee;\n        baseFee = newFee;\n        emit FeeChanged(prevFee, newFee);\n    }\n\n    /**\n     * @notice 수수료를 수취할 대상 변경\n     * @param newFeeTo 수취할 대상 주소\n     */\n    function changeFeeTo(address payable newFeeTo) external onlyOwner {\n        address prevFeeTo = feeTo;\n        feeTo = newFeeTo;\n        emit FeeToChanged(prevFeeTo, newFeeTo);\n    }\n\n    /**\n     * @notice Factori.eth에 쌓여있는 ETH와 토큰을 호출하여, 수수료 수취 주소에 전송함\n     * @param tokenAddr 수취할 토큰 주소\n     */\n    function collect(address tokenAddr) external onlyOwner {\n        IERC20(tokenAddr).transfer(feeTo, IERC20(tokenAddr).balanceOf(address(this)));\n    }\n\n    function recoverOwnership(address deployed, address to) external onlyOwner {\n        IERC173(deployed).transferOwnership(to);\n    }\n\n    function feeTransfer(address to, uint256 amount) internal returns (bool callStatus) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n            let returnDataSize := returndatasize()\n            if iszero(callStatus) {\n                returndatacopy(0, 0, returnDataSize)\n                revert(0, returnDataSize)\n            }\n        }\n    }\n}\n"
    },
    "@beandao/contracts/interfaces/IERC20.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function balanceOf(address target) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "@beandao/contracts/interfaces/IERC165.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "@beandao/contracts/library/Address.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n    function isContract(address target) internal view returns (bool result) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := gt(extcodesize(target), 0)\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/BeaconDeployer.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title BeaconDeployer\n * @author yoonsung.eth\n * @notice library that deploy Beacon contract.\n */\nlibrary BeaconDeployer {\n    function deploy(address implementation) internal returns (address result) {\n        bytes memory code = abi.encodePacked(\n            hex\"606161002960003933600081816002015260310152602080380360803960805160005560616000f3fe337f00000000000000000000000000000000000000000000000000000000000000001415602e57600035600055005b337f00000000000000000000000000000000000000000000000000000000000000001460605760005460005260206000f35b\",\n            abi.encode(implementation)\n        );\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := create(0, add(code, 0x20), mload(code))\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(extcodesize(result)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/Ownership.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC173.sol\";\n\n/**\n * @title Ownership\n * @author yoonsung.eth\n * @notice 단일 Ownership을 가질 수 있도록 도와주는 추상 컨트랙트\n * @dev constructor 기반 컨트랙트에서는 생성 시점에 owner가 msg.sender로 지정되며,\n *      Proxy로 작동되는 컨트랙트의 경우 `__transferOwnership(address)`를 명시적으로 호출하여 owner를 지정하여야 한다.\n */\nabstract contract Ownership is IERC173 {\n    address public override owner;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownership/Not-Authorized\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    function transferOwnership(address newOwner) external virtual override onlyOwner {\n        require(newOwner != address(0), \"Ownership/Not-Allowed-Zero\");\n        _transferOwnership(newOwner);\n    }\n\n    function resignOwnership() external virtual onlyOwner {\n        delete owner;\n        emit OwnershipTransferred(msg.sender, address(0));\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        address prev = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(prev, newOwner);\n    }\n}\n"
    },
    "@beandao/contracts/library/BeaconProxyDeployer.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"./BeaconMaker.sol\";\nimport \"./BeaconMakerWithCall.sol\";\n\n/**\n * @title BeaconProxyDeployer\n * @author yoonsung.eth\n * @notice Beacon Minimal Proxy를 배포하는 기능을 가진 라이브러리\n */\nlibrary BeaconProxyDeployer {\n    function deploy(address beacon, bytes memory initializationCalldata) internal returns (address result) {\n        bytes memory createCode = creation(beacon, initializationCalldata);\n\n        (bytes32 salt, ) = getSaltAndTarget(createCode);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(extcodesize(result)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function deploy(\n        string memory seed,\n        address beacon,\n        bytes memory initializationCalldata\n    ) internal returns (address result) {\n        bytes memory createCode = creation(beacon, initializationCalldata);\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(extcodesize(result)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function calculateAddress(address template, bytes memory initializationCalldata)\n        internal\n        view\n        returns (address addr)\n    {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        (, addr) = getSaltAndTarget(createCode);\n    }\n\n    function calculateAddress(\n        string memory seed,\n        address template,\n        bytes memory initializationCalldata\n    ) internal view returns (address addr) {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        addr = getTargetFromSeed(createCode, seed);\n    }\n\n    function isBeacon(address beaconAddr, address target) internal view returns (bool result) {\n        bytes20 beaconAddrBytes = bytes20(beaconAddr);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\n            mstore(add(clone, 0x6), beaconAddrBytes)\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\n\n            let other := add(clone, 0x40)\n            extcodecopy(target, other, 0, 0x3c)\n            result := eq(mload(clone), mload(other))\n        }\n    }\n\n    function getSaltAndTarget(bytes memory initCode) internal view returns (bytes32 salt, address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        // set the initial nonce to be provided when constructing the salt.\n        uint256 nonce = 0;\n\n        // declare variable for code size of derived address.\n        bool exist;\n\n        while (true) {\n            // derive `CREATE2` salt using `msg.sender` and nonce.\n            salt = keccak256(abi.encodePacked(msg.sender, nonce));\n\n            target = address( // derive the target deployment address.\n                uint160( // downcast to match the address type.\n                    uint256( // cast to uint to truncate upper digits.\n                        keccak256( // compute CREATE2 hash using 4 inputs.\n                            abi.encodePacked( // pack all inputs to the hash together.\n                                bytes1(0xff), // pass in the control character.\n                                address(this), // pass in the address of this contract.\n                                salt, // pass in the salt from above.\n                                initCodeHash // pass in hash of contract creation code.\n                            )\n                        )\n                    )\n                )\n            );\n\n            // determine if a contract is already deployed to the target address.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                exist := gt(extcodesize(target), 0)\n            }\n\n            // exit the loop if no contract is deployed to the target address.\n            if (!exist) {\n                break;\n            }\n\n            // otherwise, increment the nonce and derive a new salt.\n            nonce++;\n        }\n    }\n\n    function getTargetFromSeed(bytes memory initCode, string memory seed) internal view returns (address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        target = address( // derive the target deployment address.\n            uint160( // downcast to match the address type.\n                uint256( // cast to uint to truncate upper digits.\n                    keccak256( // compute CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            bytes1(0xff), // pass in the control character.\n                            address(this), // pass in the address of this contract.\n                            salt, // pass in the salt from above.\n                            initCodeHash // pass in hash of contract creation code.\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function creation(address addr, bytes memory initializationCalldata)\n        private\n        pure\n        returns (bytes memory createCode)\n    {\n        createCode = initializationCalldata.length > 0\n            ? abi.encodePacked(\n                type(BeaconMakerWithCall).creationCode,\n                abi.encode(address(addr), initializationCalldata)\n            )\n            : abi.encodePacked(type(BeaconMaker).creationCode, abi.encode(address(addr)));\n    }\n}\n"
    },
    "@beandao/contracts/library/MinimalProxyDeployer.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"./MinimalMaker.sol\";\nimport \"./MinimalMakerWithCall.sol\";\n\n/**\n * @title MinimalProxyDeployer\n * @author yoonsung.eth\n * @notice Minimal Proxy를 배포하는 기능을 가진 라이브러리\n */\nlibrary MinimalProxyDeployer {\n    function deploy(address template, bytes memory initializationCalldata) internal returns (address result) {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        (bytes32 salt, ) = getSaltAndTarget(createCode);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(extcodesize(result)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function deploy(\n        string memory seed,\n        address template,\n        bytes memory initializationCalldata\n    ) internal returns (address result) {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(extcodesize(result)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function calculateAddress(address template, bytes memory initializationCalldata)\n        internal\n        view\n        returns (address addr)\n    {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        (, addr) = getSaltAndTarget(createCode);\n    }\n\n    function calculateAddress(\n        string memory seed,\n        address template,\n        bytes memory initializationCalldata\n    ) internal view returns (address addr) {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        addr = getTargetFromSeed(createCode, seed);\n    }\n\n    function isMinimal(address templateAddr, address target) internal view returns (bool result) {\n        bytes20 templateAddrBytes = bytes20(templateAddr);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), templateAddrBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n            let other := add(clone, 0x40)\n            extcodecopy(target, other, 0, 0x2d)\n            result := eq(mload(clone), mload(other))\n        }\n    }\n\n    function getSaltAndTarget(bytes memory initCode) internal view returns (bytes32 salt, address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        // set the initial nonce to be provided when constructing the salt.\n        uint256 nonce = 0;\n\n        // declare variable for code size of derived address.\n        bool exist;\n\n        while (true) {\n            // derive `CREATE2` salt using `msg.sender` and nonce.\n            salt = keccak256(abi.encodePacked(msg.sender, nonce));\n\n            target = address( // derive the target deployment address.\n                uint160( // downcast to match the address type.\n                    uint256( // cast to uint to truncate upper digits.\n                        keccak256( // compute CREATE2 hash using 4 inputs.\n                            abi.encodePacked( // pack all inputs to the hash together.\n                                bytes1(0xff), // pass in the control character.\n                                address(this), // pass in the address of this contract.\n                                salt, // pass in the salt from above.\n                                initCodeHash // pass in hash of contract creation code.\n                            )\n                        )\n                    )\n                )\n            );\n\n            // determine if a contract is already deployed to the target address.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                exist := gt(extcodesize(target), 0)\n            }\n\n            // exit the loop if no contract is deployed to the target address.\n            if (!exist) {\n                break;\n            }\n\n            // otherwise, increment the nonce and derive a new salt.\n            nonce++;\n        }\n    }\n\n    function getTargetFromSeed(bytes memory initCode, string memory seed) internal view returns (address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        target = address( // derive the target deployment address.\n            uint160( // downcast to match the address type.\n                uint256( // cast to uint to truncate upper digits.\n                    keccak256( // compute CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            bytes1(0xff), // pass in the control character.\n                            address(this), // pass in the address of this contract.\n                            salt, // pass in the salt from above.\n                            initCodeHash // pass in hash of contract creation code.\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function creation(address addr, bytes memory initializationCalldata)\n        private\n        pure\n        returns (bytes memory createCode)\n    {\n        createCode = initializationCalldata.length > 0\n            ? abi.encodePacked(\n                type(MinimalMakerWithCall).creationCode,\n                abi.encode(address(addr), initializationCalldata)\n            )\n            : abi.encodePacked(type(MinimalMaker).creationCode, abi.encode(address(addr)));\n    }\n}\n"
    },
    "@beandao/contracts/library/Multicall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMulticall.sol\";\n\n/**\n * @title Multicall\n * @author yoonsung.eth\n * @notice 컨트랙트가 가지고 있는 트랜잭션을 순서대로 실행시킬 수 있음.\n */\nabstract contract Multicall is IMulticall {\n    function multicall(bytes[] calldata callData) external override returns (bytes[] memory returnData) {\n        returnData = new bytes[](callData.length);\n        for (uint256 i = 0; i < callData.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(callData[i]);\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n            if (!success) {\n                // revert called without a message\n                if (result.length < 68) revert();\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            returnData[i] = result;\n        }\n    }\n}\n"
    },
    "contracts/IFactory.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IFactory {\n    struct TemplateInfo {\n        address template;\n        address btemplate;\n    }\n\n    event Deployed(address deployed, address owner);\n    event NewTemplate(bytes32 indexed key, address template, address beacon);\n    event UpdatedTemplate(bytes32 indexed key, address template);\n    event DeletedTemplate(bytes32 indexed key);\n    event FeeChanged(uint256 prevFee, uint256 fee);\n    event FeeToChanged(address prevFeeTo, address feeTo);\n\n    function deploy(\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed);\n\n    function deployWithSeed(\n        string memory seed,\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed);\n\n    function compute(\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData\n    ) external view returns (address deployable);\n\n    function computeWithSeed(\n        string memory seed,\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData\n    ) external view returns (address deployable);\n\n    function clone(\n        address templateAddr,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed);\n\n    function computeClone(address templateAddr, bytes memory initializationCallData)\n        external\n        view\n        returns (address deployable);\n\n    function getPrice() external view returns (uint256 price);\n\n    function addTemplate(address templateAddr) external;\n\n    function updateTemplate(bytes32 key, address templateAddr) external;\n\n    function removeTemplate(bytes32 key) external;\n\n    function changeFee(uint256 newFee) external;\n\n    function changeFeeTo(address payable newFeeTo) external;\n\n    function collect(address tokenAddr) external;\n}\n"
    },
    "@beandao/contracts/interfaces/IERC173.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC-173 Contract Ownership Standard\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\n * Note: the ERC-165 identifier for this interface is 0x7f5828d0\n */\ninterface IERC173 {\n    /**\n     * @dev This emits when ownership of a contract changes.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @notice Get the address of the owner\n     * @return The address of the owner.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Set the address of the new owner of the contract\n     * @param newOwner The address of the new owner of the contract\n     */\n    function transferOwnership(address newOwner) external;\n}\n"
    },
    "@beandao/contracts/library/BeaconMaker.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title BeaconMaker\n * @author yoonsung.eth\n * @notice Beacon Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract BeaconMaker {\n    /**\n     * @param beacon call 했을 경우, 주소가 반환되어야 하는 컨트랙트\n     */\n    constructor(address beacon) payable {\n        // Beacon Address\n        bytes20 targetBytes = bytes20(beacon);\n        // place Beacon Proxy code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\n            mstore(add(clone, 0x6), targetBytes)\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\n            // return Beacon Minimal Proxy code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x3c) // Beacon Minimal Proxy runtime code, length\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/BeaconMakerWithCall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title BeaconMakerWithCall\n * @author yoonsung.eth\n * @notice Beacon Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract BeaconMakerWithCall {\n    /**\n     * @param beacon call 했을 경우, 주소가 반환되어야 함\n     * @param initializationCalldata template로 배포할 때 초기화 할 함수\n     */\n    constructor(address beacon, bytes memory initializationCalldata) payable {\n        (, bytes memory returnData) = beacon.staticcall(\"\");\n        address template = abi.decode(returnData, (address));\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = template.delegatecall(initializationCalldata);\n        if (!success) {\n            // pass along failure message from delegatecall and revert.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Beacon Address\n        bytes20 targetBytes = bytes20(beacon);\n        // place Beacon Proxy code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\n            mstore(add(clone, 0x6), targetBytes)\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\n            // return Beacon Minimal Proxy code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x3c) // Beacon Minimal Proxy runtime code, length\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/MinimalMaker.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title MinimalMaker\n * @author yoonsung.eth\n * @notice Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract MinimalMaker {\n    constructor(address template) payable {\n        // Template Address\n        bytes20 targetBytes = bytes20(template);\n        // place Minimal Proxy eip-1167 code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            // return eip-1167 code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x2d) // eip-1167 runtime code, length\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/MinimalMakerWithCall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title MinimalMakerWithCall\n * @author yoonsung.eth\n * @notice Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract MinimalMakerWithCall {\n    constructor(address template, bytes memory initializationCalldata) payable {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = template.delegatecall(initializationCalldata);\n        if (!success) {\n            // pass along failure message from delegatecall and revert.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Template Address\n        bytes20 targetBytes = bytes20(template);\n        // place Minimal Proxy eip-1167 code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            // return eip-1167 code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x2d) // eip-1167 runtime code, length\n        }\n    }\n}\n"
    },
    "@beandao/contracts/interfaces/IMulticall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IMulticall {\n    function multicall(bytes[] calldata callData) external returns (bytes[] memory returnData);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 42069,
      "details": {
        "yul": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}}